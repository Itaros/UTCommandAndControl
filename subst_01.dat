-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t UniverseID;
	typedef struct {
		uint64_t poiID;
		UniverseID componentID;
		const char* messageType;
		const char* connectionName;
		bool isCollectable;
		bool isAssociative;
	} MessageDetails;
	UniverseID GetCurrentlyScannedObject();
	const char* GetLocalizedText(const uint32_t pageid, uint32_t textid, const char*const defaultvalue);
	int GetMainMissiontargetPOSID();
	MessageDetails GetMessageDetails(const uint32_t messageid);
	float GetScanProgress(UniverseID componentid);
]]

-- settings
local config = {
	outerRingRadius = 160, -- radius of the outer ring (in px)
	innerRingRadius = 80,  -- radius of the inner ring (in px)

	iconSizeOnScreen  = 32, -- size (in px) of the icon when the target is on-screen
	iconSizeOffScreen = 16  -- size (in px) of the icon when the target is off-screen
}

-- TODO: @ Stefan med - add proper localization support for basic UI strings
-- text array containing localized text
local L = {
	["LS to choose"] = ffi.string(C.GetLocalizedText(1001, 5100, "LS to choose"))
}

-- private member data
local private = {
	crosshairElement = nil,         -- Crosshair element
	interactElement = nil,          -- Interact element
	textElement = nil,              -- the interact text element
	outerRingElement = nil,         -- the outer ring element
	outerRingDynamicElement = nil,  -- the dynamic (interaction) outer ring element
	outerArrowElement = nil,        -- the arrow element in the outer ring
	progressbarElement = nil,       -- the (scan-)progress bar element
	progressbarRangeElement = nil,  -- the range component in the progress bar element
	innerRingElement = nil,         -- the inner ring element
	missionEffectElement = nil,     -- the mission effect element
	innerArrowElement = nil,        -- the arrow element in the inner ring
	softtargetmessageid = nil,      -- id of the current softtargetmessage
	interactElementShown = false,   -- indicates whether the interaction element is shown or hidden
	scanTargetID = nil,             -- targetID of the target associated with the progressbar
	progressbarActive = false,      -- indicates whether the progressbar is active
	outerRingActive = false,        -- indicates whether a outer ring is active
	softtargetPosID = nil,          -- ID of the pos element representing the softtarget
	missionPosID = nil,             -- current mission pos ID
	innerRingActive = false,        -- indicates whether the inner ring is active
	innerArrowInside = false,       -- indicates whether the inner arrow points inside
	outerArrowInside = false,       -- indicates whether the outer arrow points inside
	previousMissiontargetX = 0,     -- previous x coordinate used for the inner ring position
	previousMissiontargetY = 0,     -- previous y coordinate used for the inner ring position
	previousSofttargetX = 0,        -- previous x coordinate used for the outer ring position
	previousSofttargetY = 0,        -- previous y coordinate used for the outer ring position
	crosshairActive = false,        -- indicates whether the crosshair is active
	rescanSlideChanges = false,     -- indicates whether all crosshair elements should be rechecked for required slide-changes
	numPossibleActions = nil,       -- number of possible actions for the softtarget
	currentInteraction = nil,       -- the current eventmonitor interaction being displayed (if any)
	interactionRingActive = false,  -- indicates whether the softtarget interaction ring is active
	interactionEffect = false,      -- indicates whether the interaction effect is to be played
	displayLSTooltip = false,       -- indicates whether the text: "LS to choose" is to be displayed
	interactText = nil,             -- the interaction text (if any) which is displayed atm
	recheckRingEffect = false,      -- indicates whether we need to recheck the ring effect
	targetText = nil                -- target text (if any) which is displayed atm
}

-- local functions forward declarations
local onControlStarted
local onControlStopped
local onInputModeChanged
local onInteractionHidden
local onInteractionShown
local onLeaveInteractMenu
local onMainMissiontargetChanged
local onObjectiveBarUpdate
local onSelectAction
local onSofttargetChanged
local onScanStarted
local onScanAborted
local onScanFinished
local onUnlock
local onButtonDown
local onButtonUp
local abortScan
local activateCrosshair
local activateInnerRing
local activateInteractElement
local activateInteractionRing
local activateOuterRing
local activateProgressBar
local activationScan
local checkActionEffect
local deactivateCrosshair
local deactivateInnerRing
local deactivateInteractElement
local deactivateInteractionRing
local deactivateOuterRing
local deactivateProgressBar
local finishScan
local startScan
local switchInteractState
local triggerMissionRingEffect
local updateArrowOrientation
local updateArrowPosition
local updateInnerRing
local updateProgressBar
local updateOuterRing
local updateText

-- Gameface lifetime functions
function self:onInitialize()
	local scene = getElement("Scene")
	local layer = getElement("Layer", scene)
	private.crosshairElement          = getElement("crosshair", layer)
	private.interactElement           = getElement("interact", layer)
	private.textElement               = getElement("Text", private.interactElement)
	private.innerRingElement          = getElement("missiontarget.ring", private.crosshairElement)
	private.missionEffectElement      = getElement("missioneffect", private.crosshairElement)
	private.innerArrowElement         = getElement("arrow", private.innerRingElement)
	private.outerRingElement          = getElement("softtarget.ring", private.crosshairElement)
	private.outerRingDynamicElement   = getElement("dynamic", private.outerRingElement)
	private.outerArrowElement         = getElement("arrow", private.outerRingDynamicElement)
	private.progressbarElement        = getElement("progressbar", private.crosshairElement)
	private.progressbarRangeElement   = getElement("ring", private.progressbarElement)
	private.playership = GetPlayerPrimaryShipID()
	

	-- register for events
	local contract = getElement("UIContract", scene)
	registerForEvent("missionobjectivebarupdate", contract, onObjectiveBarUpdate)
	registerForEvent("controlStarted",            contract, onControlStarted)
	registerForEvent("controlStopped",            contract, onControlStopped)
	registerForEvent("inputModeChanged",          contract, onInputModeChanged)
	registerForEvent("mainMissiontargetChanged",  contract, onMainMissiontargetChanged)
	registerForEvent("leaveInteractMenu",         contract, onLeaveInteractMenu)
	registerForEvent("interactionHidden",         contract, onInteractionHidden)
	registerForEvent("interactionShown",          contract, onInteractionShown)
	registerForEvent("scanStarted",               contract, onScanStarted)
	registerForEvent("scanAborted",               contract, onScanAborted)
	registerForEvent("scanFinished",              contract, onScanFinished)
	registerForEvent("selectAction",              contract, onSelectAction)
	registerForEvent("softtargetChanged",         contract, onSofttargetChanged)
	registerForEvent("onUnlock",                  contract, onUnlock)
	registerForEvent("onButtonDown",  contract, onButtonDown)
	registerForEvent("onButtonUp",  contract, onButtonUp)

	-- notify on game events
	NotifyOnScanStarted(contract)
	NotifyOnScanAborted(contract)
	NotifyOnScanFinished(contract)
	NotifyOnPlayerControlStarted(contract)
	NotifyOnPlayerControlStopped(contract)
	NotifyOnMissionObjectiveBarUpdate(contract)

	if HasFlightControl() then
		activateCrosshair()
	else
		deactivateCrosshair()
	end

	-- enable gamepad specific visuals
	if GetControllerInfo() == "gamepad" then
		private.displayLSTooltip  = true
		private.interactionEffect = true
	end

	-- initialize the main missiontarget ring correctly (note: at the time of coding this, C.GetMainMissiontargetPOSID() will always return nil here - this is due to the fact
	-- that the crosshair is initialized alongside the target system --- if that ever changes, this code ensures that the main mission target is correctly initialized)
	local posID = C.GetMainMissiontargetPOSID()
	if posID == -1 then
		posID = nil
	end
	onMainMissiontargetChanged(nil, posID)

	-- initialize the scan progress
	local componentid = C.GetCurrentlyScannedObject()
	if componentid ~= 0 then
		startScan(componentid)
	end
end

function self:onUpdate()
	if not private.crosshairActive then
		return -- for an inactive crosshair we've got nothing to do atm (no relevant state changes here)
	end

	if private.rescanSlideChanges then
		activationScan()
	end

	if private.progressbarActive then
		updateProgressBar()
	end

	if private.interactionRingActive then
		checkActionEffect()
	end

	if private.recheckRingEffect then
		local objective = GetMissionObjectiveBarInfo()
		if objective ~= nil then
			triggerMissionRingEffect()
		end
		private.recheckRingEffect = false
	end

	-- update the OOV rings
	-- #StefanLow --- this could be an unnecessary performance impact here --- we should not be required to update the rotation every frame
	-- but on the other hand we expect that the player always does have a softtarget/missiontarget --- hence, it'd be updated every frame anyway
	-- hence the performance loss should be neglactable (=> low prio)
	updateOuterRing()
	updateInnerRing()
end

-------------------------------------
-- Presentation specific callbacks --
-------------------------------------
function onControlStarted()
	activateCrosshair()
end

function onControlStopped()
	deactivateCrosshair()
end

function onInputModeChanged(_, mode)
	if mode == "gamepad" then
		private.displayLSTooltip  = true
		private.interactionEffect = true
		if private.softtargetmessageid then
			-- #StefanMed - only activate, when actions are there...
			activateInteractionRing()
		end
	else -- mouse-mode (aka: either "mouseSteering" or "mouseCursor")
		if private.LSTooltipDisplayed then
			-- ensure that "LS to choose" is removed, in case it was displayed before (if LSTooltipDisplayed is false, the text atm displays the instant action, which should stay)
			private.LSTooltipDisplayed = false
			updateText()
		end
		private.displayLSTooltip  = false
		private.interactionEffect = false
		deactivateInteractionRing()
	end
end

function onLeaveInteractMenu()
	if private.LSTooltipDisplayed then
		private.LSTooltipDisplayed = false
		updateText()
	end
end

function onMainMissiontargetChanged(_, posID)
	private.missionPosID = posID

	if posID ~= nil then
		activateInnerRing()
	else
		deactivateInnerRing()
	end
end

function onInteractionHidden(_, interactionID)
	if interactionID ~= private.currentInteraction then
		return -- different interaction ID - might occur, when we retrieve successive shown/hidden interaction events
	end

	private.interactText = nil
	private.currentInteraction = nil
	updateText()
end

function onInteractionShown(_, interactionID, interactionText)
	private.currentInteraction = interactionID
	-- do not display the text (and background element), if we have either no interaction (nil) or the interaction doesn't specify a to displayed text ("")
	if interactionText ~= nil and interactionText ~= "" then
		private.interactText = interactionText
		updateText()
	end
end

function onObjectiveBarUpdate()
	-- note: we are not performing the check instantly here, since the event could be triggered multiple times per frame
	private.recheckRingEffect = true
end

function onScanStarted(_, componentID)
	startScan(componentID)
end

function onScanAborted()
	abortScan()
end

function onScanFinished()
	finishScan()
end

function onSelectAction(_, action)
	if action == 0 and private.displayLSTooltip then
		private.LSTooltipDisplayed = true
	else
		private.LSTooltipDisplayed = false
	end
	updateText()
end

function onSofttargetChanged(_, newsofttargetmessageid, posID)
	local numPossibleActions
	-- just flag the softtarget change, don't do it right away here, since a goToSlide() call might be pending which
	-- might not have been processed just yet
	if newsofttargetmessageid then
		local details = C.GetMessageDetails(newsofttargetmessageid)
		-- newsofttargetmessageid could point to an invalid (aka already destroyed) message -- this can happen, if the message was being destroyed in-between the
		-- softtarget changed event dispatch process --- so we have to handle and recheck this here
		if details.componentID == 0 then
			newsofttargetmessageid = nil -- reset to nils
			posID = nil
			deactivateOuterRing()
			deactivateInteractionRing()
			private.targetText = nil
		else
			-- valid id, so activate the softtarget
			activateOuterRing()

			-- get action info to display instant actions for current target (note that non-instant actions are handled in onShowInteractMenu)
			local actionname, numActions, instantAction
			actionname, isPossible, numActions, instantAction, _, _, numPossibleActions = GetActionInfo(newsofttargetmessageid)
			if not instantAction then
				actionname = ""
			end
			-- #StefanMed - would be even better, if that was done with a live-update (aka: text is displayed when it's possible, and disappears when it's no longer possible - aka: onUpdate-check)
			if actionname ~= "" and isPossible then
				private.targetText = actionname
			else
				private.targetText = nil
			end

			-- #StefanMed - how about actions which are all impossible and none are displayed?
			if numActions and numActions > 0 then
				activateInteractionRing()
			end
		end
	else
		deactivateOuterRing()
		deactivateInteractionRing()
		private.targetText = nil
	end
	updateText()

	private.softtargetmessageid = newsofttargetmessageid
	private.softtargetPosID = posID
	private.numPossibleActions = numPossibleActions
end

function onUnlock()
	-- reset crosshair state (could have changed when player entered/left stations/drones or started a new game)

	-- see XT-3826 for a list of outstanding tasks

	-- we just reset the interact menu state --- proper handling would not be that easy, since it requires inter-LuaState-handling (state is stored in the target system)
	deactivateInteractionRing()

	-- we just reset the interaction --- proper handling would not be that easy, since it requires inter-LuaState-handling (state is stored in the event monitor)
	-- #StefanMed - with the change to use eventmonitor interactions in the dock case now, we might actually want to higher prioritze this one
	onInteractionHidden(nil, private.currentInteraction)

	-- update the main missiontarget
	local posID = C.GetMainMissiontargetPOSID()
	if posID == -1 then
		posID = nil
	end
	onMainMissiontargetChanged(nil, posID)

	-- just reset the softtarget state --- practically this is not an issue, since we always get a softtarget-update-event
	-- #StefanLow - handle that by updating the softtarget (in case we ever change the behavior of the unlocking/locking behavior or the initialization order
	-- and hence can no longer rely on the current fact that we always do get an onSofttargetChanged-event after unlocking)
	onSofttargetChanged(nil, nil, nil)

	-- update controling based states
	if HasFlightControl() then
		activateCrosshair()
	else
		deactivateCrosshair()
	end

	-- update scan progress
	local componentID = C.GetCurrentlyScannedObject()
	if componentID ~= 0 then
		startScan(componentID)
	else
		deactivateProgressBar("inactive")
	end

	-- update states related to possible input-control-changes
	onInputModeChanged(nil, GetControllerInfo())

	-- update text element
	updateText()
end

------------------------------------
-- Presentation specific function --
------------------------------------

function onButtonDown(_, button)
	DebugError("Event Key Down received, Burron: "..button.." pressed ")
	SignalObject(playership , "KeyDown" , button )
end


function onButtonUp(_, button)
	DebugError("Event Key Up received, Burron: "..button.." released ")
	SignalObject(playership , "KeyUp" , button )
end

function abortScan()
	deactivateProgressBar("abort")
	PlaySound("ui_hud_soft_scan_neg_core")
end

function activateCrosshair()
	if private.crosshairActive then
		return -- already active, nothing to do
	end

	-- #StefanMed - review the rescanSlideChanges-behavior --- maybe deprecated? or at least should be cleaned-up

	goToSlide(private.crosshairElement, "active")
	private.crosshairActive = true
	private.rescanSlideChanges = true
	updateText()
end

function activateInteractElement()
	if private.interactElementShown then
		return -- nothing to do, element already displayed
	end

	goToSlide(private.interactElement, "appear")
	private.interactElementShown = true
end

function activateInteractionRing()
	if not private.interactionEffect then
		return -- no interaction effect to be used
	end

	if private.crosshairActive then
		switchInteractState("to-interact")
	end

	private.interactionRingActive = true
end

function activateInnerRing()
	if private.innerRingActive then
		return -- nothing to do
	end

	if private.crosshairActive then
		goToSlide(private.innerRingElement, "fadein")
	end
	private.innerRingActive = true
end

function activateOuterRing()
	if private.outerRingActive then
		return -- nothing to do
	end

	if private.crosshairActive then
		goToSlide(private.outerRingElement, "fadein")
	end
	private.outerRingActive = true
end

function activateProgressBar(targetID)
	private.scanTargetID = targetID
	private.progressbarActive = true

	if private.crosshairActive then
		goToSlide(private.progressbarElement, "active")
	end
end

function activationScan()
	if private.innerRingActive then
		goToSlide(private.innerRingElement, "fadein")
	end
	if private.outerRingActive then
		goToSlide(private.outerRingElement, "fadein")
	end
	if private.interactElementShown then
		goToSlide(private.interactElement, "appear")
	end
	if private.progressbarActive then
		goToSlide(private.progressbarElement, "active")
	end

	private.rescanSlideChanges = false
end

function checkActionEffect()
	local _, _, _, _, _, _, numPossibleActions = GetActionInfo(private.softtargetmessageid)

	-- #StefanMed - what if numPossibleActions did not change, but rahter one action became inactive while the other became active?
	if private.numPossibleActions ~= numPossibleActions then
		private.numPossibleActions = numPossibleActions
		switchInteractState("new-interact")
	end
end

function deactivateCrosshair()
	if not private.crosshairActive then
		return -- already inactive, nothing to do
	end

	goToSlide(private.crosshairElement, "inactive")
	goToSlide(private.interactElement, "inactive")

	-- also hide all separate elements
	if private.outerRingActive then
		goToSlide(private.outerRingElement, "fadeout")
	end
	if private.progressBarActive then
		goToSlide(private.progressbarElement, "active")
	end
	if private.innerRingActive then
		goToSlide(private.innerRingElement, "fadeout")
	end
	goToSlide(private.missionEffectElement, "inactive")
	if private.interactElementShown then
		goToSlide(private.interactElement, "disappear")
	end

	private.crosshairActive = false
	updateText()
end

function deactivateInteractElement()
	if not private.interactElementShown then
		return -- already hidden
	end

	goToSlide(private.interactElement, "disappear")
	private.interactElementShown = false
end

function deactivateInteractionRing()
	if not private.interactionRingActive then
		return -- already hidden
	end

	switchInteractState("leave-interact")
	private.interactionRingActive = false
end

function deactivateInnerRing()
	if not private.innerRingActive then
		return -- nothing to do
	end

	if private.crosshairActive then
		goToSlide(private.innerRingElement, "fadeout")
	end
	private.innerRingActive = false
end

function deactivateProgressBar(type)
	private.scanTargetID = nil
	private.progressbarActive = false

	if private.crosshairActive then
		goToSlide(private.progressbarElement, type)
	end
end

function deactivateOuterRing()
	if not private.outerRingActive then
		return -- nothing to do
	end

	if private.crosshairActive then
		goToSlide(private.outerRingElement, "fadeout")
	end
	private.outerRingActive = false
end

function finishScan()
	deactivateProgressBar("finish")
	PlaySound("ui_hud_soft_scan_pos_core")	
end

function startScan(scanTargetID)
	activateProgressBar(scanTargetID)
end

function switchInteractState(state)
	goToSlide(private.outerRingDynamicElement, state)

	-- reset slides of child components, so they are not reset to slide 1
	if private.outerArrowInside then
		goToSlide(private.outerArrowElement, "inside")
	else
		goToSlide(private.outerArrowElement, "outside")
	end
end

function updateInnerRing()
	local x2d = private.previousMissiontargetX
	local y2d = private.previousMissiontargetY

	if private.innerRingActive then
		-- no need to handle firstperson case here --- presentation only used for non-firstperson case
		local curx2d, cury2d = GetUIElementScreenPosition(private.missionPosID, config.iconSizeOnScreen, config.iconSizeOffScreen)
		if curx2d then
			x2d = curx2d
			y2d = cury2d
			private.previousMissiontargetX = x2d
			private.previousMissiontargetY = y2d
			private.innerArrowInside = updateArrowOrientation(private.innerArrowElement, private.innerArrowInside, x2d, y2d, config.innerRingRadius)
		end
	end
	updateArrowPosition(private.innerRingElement, x2d, y2d)
end

function updateProgressBar()
	local percent = C.GetScanProgress(private.scanTargetID)
	goToTime(private.progressbarRangeElement, percent)
end

function updateOuterRing()
	local x2d = private.previousSofttargetX
	local y2d = private.previousSofttargetY

	if private.outerRingActive then
		-- #StefanLow - 32 should actually be set to the correct iconsize
		local curx2d, cury2d = GetUIElementScreenPosition(private.softtargetPosID, config.iconSizeOnScreen, config.iconSizeOffScreen)
		if curx2d then
			x2d = curx2d
			y2d = cury2d
			private.previousSofttargetX = x2d
			private.previousSofttargetY = y2d
			private.outerArrowInside = updateArrowOrientation(private.outerArrowElement, private.outerArrowInside, x2d, y2d, config.outerRingRadius)
		end
	end
	updateArrowPosition(private.outerRingElement, x2d, y2d)
end

function triggerMissionRingEffect()
	goToSlide(private.missionEffectElement, "active")
end

function updateArrowOrientation(arrowElement, isInside, x2d, y2d, radius)
	local curRadius = math.sqrt(x2d * x2d + y2d * y2d)
	local inside = curRadius < radius
	if inside and not isInside then
		goToSlide(arrowElement, "swap_inside")
		return true
	elseif not inside and isInside then
		goToSlide(arrowElement, "swap_outside")
		return false
	end
	return isInside -- unchanged
end

function updateArrowPosition(ringElement, x2d, y2d)
	-- #StefanLow - use rad directly
	local angle = math.atan2(y2d, x2d) * 180 / math.pi -- rad -> deg

	-- converting angle from atan2 (counterclockwise, 0 degree to the right) to our
	-- required format (clockwise, 0 degree at top)
	angle = -angle + 90

	-- normalize the angle betwee 0..360 degree
	while angle < 0 do
		angle = angle + 360
	end
	while angle > 360 do
		angle = angle - 360
	end

	setAttribute(ringElement, "rotation.z", (-angle)/180 * math.pi)
end

function updateText()
	local text = ""
	if private.crosshairActive then
		-- text is only set, if the crosshair is active
		if private.interactText ~= nil then
			text = private.interactText
		elseif private.LSTooltipDisplayed then
			text = L["LS to choose"]
		elseif private.targetText ~= nil then
			text = private.targetText
		end
	end
	
	if text ~= "" then
		activateInteractElement()
		setAttribute(private.textElement, "textstring", text)
	else
		deactivateInteractElement()
	end
end