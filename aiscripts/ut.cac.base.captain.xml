<?xml version="1.0" encoding="UTF-8"?>
<aiscript xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="ut.cac.base.captain" xsi:noNamespaceSchemaLocation="http://utnas/~unitrader/XRebirthxsds/aiscripts.xsd" version="1">
  <!-- this is basically just a Script which executes previously given Orders in order and falls back to a logical default behavior depending on context (a very stupid script - the logic is to be implemented in other scripts) -->
  <interrupts>
    <handler comment="Print Script Vars">
      <conditions>
        <event_object_signalled object="this" param="'print script vars to logfile'"/>
      </conditions>
      <actions>
        <debug_text filter="general" text="'\n
        Captain Name ' + this.knownname + ' at Time ' + player.age + '\n
        ut.cac.base.captain Script Values:\n
        this.$orderlist = ' + this.$orderlist + '\n
        $repeat = ' + @$repeat + '\n
        $trade = ' + @$trade + '\n
        NOTE: ONLY VALUES I CREATED MYSELF INCLUDED - nothing from C+P Code Snippets
        '"/>
      </actions>
    </handler>
    <!-- here are all Signals listed the planned Navigation Script(s) will send with a short description what they do - this is just a declaration of intention, nothing is actually used/implemented so far.-->
    <handler>
      <conditions>
        <check_any>
        <event_object_signalled object="this.ship" param="'travel jump prep'" param2="$destination" param3="$follower_list" comment="
        Signals Followers that this Ship wants to Jump to $destination - small craft may now register in $follower_list that they want to dock here before the Ship charges (they shall take care of this themselves) and remove themselves from the List when docked.
        Big Ships may add themselves to the List when they want to follow and they have Followers which have to dock first and remove themselves when their Followers are prepared"/>
        <event_object_signalled object="this.ship" param="'travel jump start'" param2="$destination" comment="
        Signals Followers that this Ship wants to Jump to $destination - Jumpdrive now actually Charges (the fast charge, not the 10 minute slow one - that one will signal in the last 10s when Jumpdrive really starts) and Followers should do the same"/>
        <event_object_signalled object="this.ship" param="'emergency jump'" param2="$destination" comment="
        Signals Followers that this Ship does an Emergency Jump immediately - other Big Ships may decide to follow or to continue Battle.
        Small Craft try to Dock while JD charges and will re-assign to another mothership if not successful or try to get back to their Group"/>
        <event_object_signalled object="this.ship" param="'travel boost prep'" param2="$destination" param3="$follower_list" comment="see above - just for boost"/>
        <event_object_signalled object="this.ship" param="'travel boost start'" param2="$destination" comment="see above - just for boost"/>
        <event_object_signalled object="this.ship" param="'emergency boost'" param2="$destination" comment="see above - just for boost"/>
        </check_any>
      </conditions>
    </handler>
    <handler>
      <!-- 
      add a new Order to the queue - param2 = Order List; param3 = Position in List (0=end; 1=first, interrupt current Order (will be repeated), any other Number: Insert at Position)
      Order List Structure is a table, which contains all Info about the Script.
      Keys used here: 
      $script - Script Name as String
      -->
      <conditions>
        <check_any>
          <event_object_signalled object="this.ship" param="'new order'"/>
          <event_object_signalled object="this.ship" param="'interrupt order'"/>
        </check_any>
      </conditions>
      <actions>
        <debug_text filter="general" chance="this.$debug * 100" text="'%1 %2 %3 %4:\nevent.param= %5 event.param2= %6 event.param3= %7'.[player.age,this.name,this.container.name,event.name,event.param,event.param2,event.param3]"/>
        <do_if value="typeof event.param2.{1} == datatype.list or typeof event.param2.{1} == datatype.table" negate="true">
          <!-- a List of new Orders has been passed instead of a single Order - make it a List for compatibility with multi-order-adding -->
          <set_value name="$new_orders" exact="[ event.param2 ]" />
        </do_if>
        <do_else>
          <set_value name="$new_orders" exact="event.param2" />
        </do_else>
        <do_if value="event.param == 'interrupt order'" >
          <!-- add Order as first one -->
          <set_value name="$new_order_pos" exact="1" />
        </do_if>
        <do_elseif value="event.param3 ge 1" >
          <!-- add Order at specified position -->
          <set_value name="$new_order_pos" exact="event.param3" />
        </do_elseif>
        <do_else>
          <!-- add Order as last one -->
          <set_value name="$new_order_pos" exact="this.$orderlist.count + 1" />
        </do_else>
        <!-- reverse to keep the order of the new orders, we just want the list to be inserted at the specified position and going forward through the list would reverse their order -->
        <do_all exact="$new_orders.count" counter="$i" reverse="true">
          <do_if value="$new_order_pos == 1" comment="insert as first order interrupting the current one">
            <!-- ToDo: implement Condition for uninterruptable Orders like Docking, which should not be aborted (insert as second in this case)-->
            <do_if value="true">
              <set_value name="this.$orderlist.{1}" exact="$new_orders.{$i}" operation="insert"/>
              <abort_scripts entity="this"/>
              <resume label="start"/>
            </do_if>
            <do_else>
              <set_value name="this.$orderlist.{2}" exact="$new_orders.{$i}" operation="insert"/>
            </do_else>
          </do_if>
          <do_else comment="insert order at specific position in queue">
            <set_value name="this.$orderlist.{$new_order_pos}" exact="$new_orders.{$i}" operation="insert"/>
          </do_else>
        </do_all>
      </actions>
    </handler>
    <handler>
      <!-- cancel the current Order and continue with the next one -->
      <conditions>
        <event_object_signalled object="this.ship" param="'next order'"/>
      </conditions>
      <actions>
        <debug_text filter="general" chance="this.$debug * 100" text="'%1 %2 %3 %4:\nevent.param= %5 event.param2= %6 event.param3= %7'.[player.age,this.name,this.container.name,event.name,event.param,event.param2,event.param3]"/>
        <!-- ToDo: implement Condition for uninterruptable Orders (do nothing-cases) like Docking, which should not be aborted-->
        <remove_value name="this.$orderlist.{1}"/>
        <abort_scripts entity="this"/>
        <resume label="start"/>
      </actions>
    </handler>
  </interrupts>
  <init comment="create Joblist">
  </init>
  <attention min="unknown">
    <actions>
      <label name="start"/>
      <do_if value="not this.$orderlist?">
        <create_list name="this.$orderlist"/>
      </do_if>
      
      <!-- first get to free Space/Undock, leave formations etc. to have a safe initial state -->
      <run_script name="'ut.cac.com.captain.move.free'"/>
      
      <label name="start with orderlist"/>
      
      <!-- fulfill all Orders in List in their order -->
      <do_while value="this.$orderlist.count gt 0">
        <debug_text filter="general" chance="this.$debug * 100" text="'%1 %2 %3 Command Queue: \n%4'.[player.age,this.name,this.container.name,this.$orderlist]"/>
        <set_value name="$order" exact="this.$orderlist.{1}" />
        <do_if value="typeof $order == datatype.table">
          <remove_value name="$repeat"/>
          <run_script name="$order.$script">
            <param name="params" value="$order" />
            <save_retval name="repeat" variable="$repeat"/>
          </run_script>
          <do_if value="not $repeat"/><!-- case 0/false - dont copy/re-execute the Order -->
          <do_elseif value="$repeat == 1" >
            <!-- case 1/true -> copy Order to the end of the list -->
            <append_to_list name="this.$orderlist" exact="$order"/>
          </do_elseif>
          <do_else>
            <!-- case other number -> copy Order to specified position (except 0/false, which says dont repeat) -->
            <set_value name="this.$orderlist.{$repeat}" exact="$order" operation="insert"/>
          </do_else>
        </do_if>
        <do_else comment="Legacy Code for old, list based Order system - please use the new, table-based Order system instead">
        <debug_text filter="error" text="'Depracted Method for Orders used - please convert to the new table-based Order system:\n'+$order"/>
        <!-- look up if this Order is to be repeated (before executing it in case the Order gets interrupted/overridden - it shall still be repeated later) -->
        <do_if value="$order.{2} == 1" >
          <!-- case 1/true -> copy Order to the end of the list -->
          <append_to_list name="this.$orderlist" exact="$order"/>
        </do_if>
        <do_elseif value="@$order.{2}.isnumeric and $order.{2} != 0" >
        </do_elseif>
        <!-- differ between all implemented Orders (sadly no support for dynamic parameter Names, because then i would make use of that )-->
        <do_if value="$order.{1} == 'patrol'">
          <!-- ################################# -->
          <!-- ToDo: implement Timeout - currently this Order will not exit (use signal 'next order' to force it)-->
          <run_script name="'move.patrol'">
            <param name="range" value="$order.{3}"/>
            <param name="timeout" value="$order.{4}"/>
          </run_script>
        </do_if>
        <do_elseif value="$order.{1} == 'fly to'">
          <run_script name="'move.generic'">
            <param name="destination" value="$order.{3}"/>
            <param name="endintargetzone" value="@$order.{4}"/>
          </run_script>
        </do_elseif>
        <do_elseif value="$order.{1} == 'dock at'">
          <run_script name="'move.dockat'">
            <param name="destination" value="$order.{3}"/>
            <param name="dockingslot" value="$order.{4}"/>
          </run_script>
        </do_elseif>
        <do_elseif value="$order.{1} == 'wait'">
          <do_if value="(typeof $order.{4}).isstring">
            <do_if value="not $order.{3}">
              <set_value name="$order.{3}" exact="this.ship"/>
            </do_if>
            <do_if value="not $order.{5}">
              <set_value name="$order.{5}" exact="10h"/>
            </do_if>
            <do_if value="$order.{3}.exists">
              <wait exact="$order.{5}">
                <interrupt><conditions><check_any>
                  <event_object_destroyed object="$order.{3}"/>
                  <event_object_signalled object="$order.{3}" param="$order.{4}" />
                </check_any></conditions></interrupt>
              </wait>
            </do_if>
          </do_if>
        </do_elseif>
        <do_elseif value="$order.{1} == 'signal'">
          <do_if value="not $order.{3}">
            <set_value name="$order.{3}" exact="this.ship"/>
          </do_if>
          <signal_objects object="$order.{3}" param="$order.{4}" param2="$order.{5}" param3="$order.{6}"/>
        </do_elseif>
        <do_elseif value="$order.{1} == 'trade'">
          <!-- ToDo: write own Trade Script which is better suited for my purposes (with Signals, return Values, just one Action etc.)-->
          <run_script name="'ut.cac.com.captain.performsingletraderun'">
            <param name="undock" value="'checknexttrade'"/>
          </run_script>
        </do_elseif>
        <do_elseif value="$order.{1} == 'refuel'">
          <!-- ToDo: maybe turn this into a Trade Offer to be executed immediately once? -->
          <do_if value="this.ship.cargo.{ware.fuelcells}.count lt $order.{3}">
            <run_script name="'move.refuel'"/>
          </do_if>
          <do_elseif value="this.ship.cargo.{ware.fuelcells}.count lt $order.{3} * 2 " comment="double the reserve amount if we are nearby a Fuelstation anyway">
            <find_station name="$fuelstation" space="this.zone">
              <match_selloffer wares="[ware.fuelcells]"/>
            </find_station>
            <do_if value="$fuelstation.exists">
              <run_script name="'move.refuel'"/>
            </do_if>
          </do_elseif>
        </do_elseif>
        </do_else>
        <!-- remove current Order so we can get to the next one - after that wait a split-second to prevent Freezes should something go wrong-->
        <remove_value name="this.$orderlist.{1}" />
        <wait exact="100ms"/>
      </do_while>
      
      <!-- no outstanding direct Orders - append a default Order which makes the most sense in the current context and restart -->
      
      <label name="find job"/>
      
      <!-- if there are outstanding Trade Orders: do trade. -->
      <get_trade_from_shoppinglist object="this.ship" result="$trade"/>
      <do_if value="$trade.exists">
        <append_to_list name="this.$orderlist" exact="table[$script='ut.cac.com.captain.performsingletraderun',$repeat=0]"/>
        <resume label="start"/>
      </do_if>
      
      <!-- if Ship needs Repairs or re-arming: move to Shipyard - will be forced by Engineer/DO in urgent cases so wrecked checks should be unnecesary (not implemented yet) -->
      <!--find_object_component name="$needsrepairs" object="this.ship" checkoperational="false" comment="just see if we can find something damaged">
        <match_any>
          <match restorable="true" comment="wrecked or"/>
          <match_hull max="95" comment="damaged below 95%" />
        </match_any>
      </find_object_component-->
      <!-- Check if we have enough Ammo here - currently no Ammo usage, so unnecesary, but here is the point to add it.-->
      <!--do_if value="$needsrepairs? or this.ship.hullpercentage lt 95.0">
        <append_to_list name="this.$orderlist" exact="['visit shipyard' , 0 ]"/>
        <resume label="start"/>
      </do_if-->
      
      <!-- Signal the Superior we are now Free and want something to do -->
      <do_if value="this.ship.commanderentity == player.entity" comment="Subordinate of the Player - currently not in my Plan, so either wait where you are (Trade Ships) or Patrol the current Sector (Battleships) until further Notice" >
        <do_if value="this.ship.primarypurpose == objectpurpose.fight">
          <!-- Patrol for 1h in the Sector and then pester again -->
          <append_to_list name="this.$orderlist" exact="['patrol' , 0 , 'sector' , 1h ]"/>
          <resume label="start"/>
        </do_if>
        <do_else comment="this.ship.primarypurpose == objectpurpose.trade">
          <!-- wait at current Position until given a new Order, pester again after 1h -->
          <append_to_list name="this.$orderlist" exact="table[$script='ut.cac.microorder',$order='wait signal',$signalobject=this,$signalparam='new order',$repeat=0]"/>
          <resume label="start"/>
        </do_else>
      </do_if>
      <do_else>
        <append_to_list name="this.$orderlist" exact="table[$script='ut.cac.microorder',$order='wait exact signal',$time=5s,$signalobject=this,$signalparam='new order',$repeat=0]"/>
        <signal_objects object="this.ship.commanderentity" param="'request orders'" param2="this"/>
      </do_else>
      
      
      <resume label="start"/>
    </actions>
  </attention>
  <on_abort>
    <!-- remove all trade Orders and Reservations -->
    <get_trade_from_shoppinglist result="$trades" object="this.ship" multiple="true" />
    <do_all exact="@$trades.count" counter="$i">
      <remove_ware_reservation object="$trades.{$i}.owner" entity="this" ware="$trades.{$i}.ware"/>
      <remove_trade_order object="this.ship" trade="$trades.{$i}"/>
    </do_all>
  </on_abort>
</aiscript>
